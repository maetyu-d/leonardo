<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Minimal RC Line-Car â€” adjustable right wheels</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #sliderContainer { display:none; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); color: #fff; padding: 10px 14px; border-radius: 8px; font-size: 28px; border: 1px solid rgba(255,255,255,0.2); }
    .overlay { position: fixed; left: 50%; transform: translateX(-50%); width: min(900px, 80vw); text-align: center; color: #fff; padding: 8px 10px; font-size: 32px; }
    .lower-third { top: calc(66vh); } /* moved down by 100px */
    .overlay.hidden { display: none; }
    #endOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; color: white; display: flex; justify-content: center; align-items: center; font-size: 48px; text-align: center; padding: 20px; box-sizing: border-box; }
    #endOverlay.hidden { display: none; }
    #pressE { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 64px; font-weight: bold; color: #fff; }
    #pressE.hidden { display: none; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
</head>
<body>
  <div id="introOverlay" class="overlay lower-third">
    The Up/Down arrow keys control the throttle, Left/Right arrow keys steer. Take a few moments to get used to the handling.
  </div>
  <div id="phase2Overlay" class="overlay lower-third hidden">
    The larger wheels on the right side of the car approximate the artist's leg length discrepancy (LLD). You can use the slider to explore the effects of different wheel sizes on steering and movement.
  </div>

  <div id="sliderContainer">
    Right wheel size: <input type="range" id="wheelSlider" min="1" max="4" step="0.01" value="1.75"> <span id="wheelVal">1.75</span>x
  </div>

  <div id="pressE" class="hidden">Press 'e' to end.</div>
  <div id="endOverlay" class="hidden">
    <div style="max-width: 900px; margin: 0 auto;">
      It's fun to try out extreme values, but notice how even a small asymmetry made a big difference to the steering and how the toy car moved around the space?
    </div>
  </div>

  <script>
    let car, trailLayer;
    let startTime;
    let slider, sliderValSpan;
    let secondPhase = false;
    let phaseTwoStartTime = null;
    let endState = false;

    function setup() {
      createCanvas(window.innerWidth, window.innerHeight);
      pixelDensity(1);
      trailLayer = createGraphics(width, height);
      clearTrail();
      car = new RCcar(width*0.5, height*0.5, -HALF_PI);
      startTime = millis();

      slider = document.getElementById("wheelSlider");
      sliderValSpan = document.getElementById("wheelVal");
      slider.addEventListener("input", () => {
        car.rR = parseFloat(slider.value);
        sliderValSpan.textContent = slider.value;
      });

      setTimeout(() => document.getElementById('introOverlay').classList.add('hidden'), 10000);
    }

    function windowResized() {
      const snapshot = trailLayer.get();
      resizeCanvas(window.innerWidth, window.innerHeight);
      const newLayer = createGraphics(width, height);
      newLayer.background('#000000');
      newLayer.image(snapshot, 0, 0);
      trailLayer = newLayer;
    }

    function draw() {
      if (endState) return; // stop drawing when ended

      if (!secondPhase && millis() - startTime > 40000) {
        secondPhase = true;
        phaseTwoStartTime = millis();
        document.getElementById("sliderContainer").style.display = "block";
        clearTrail();
        const p2 = document.getElementById('phase2Overlay');
        p2.classList.remove('hidden');
        setTimeout(() => p2.classList.add('hidden'), 10000);
      }

      if (secondPhase && millis() - phaseTwoStartTime > 30000) {
        document.getElementById('pressE').classList.remove('hidden');
      }

      image(trailLayer, 0, 0);

      const throttleCmd = (keyIsDown(UP_ARROW) ? 1 : 0) + (keyIsDown(DOWN_ARROW) ? -1 : 0);
      const steerCmd = (keyIsDown(RIGHT_ARROW) ? 1 : 0) + (keyIsDown(LEFT_ARROW) ? -1 : 0);

      car.update(throttleCmd, steerCmd, deltaTime/1000);
      car.draw();
    }

    function clearTrail(){
      trailLayer.background('#000000');
    }

    function keyPressed(){
      if (endState) return;
      if (key === 'C' || key === 'c') clearTrail();
      if (key === 'R' || key === 'r') car.reset(width*0.5, height*0.5, -HALF_PI);
      if (key === 'E' || key === 'e') {
        document.getElementById('pressE').classList.add('hidden');
        document.getElementById('endOverlay').classList.remove('hidden');
        endState = true;
      }
    }

    class RCcar {
      constructor(x, y, heading){
        this.x = x; this.y = y; this.h = heading;
        this.wheelbase = 75; // 50% bigger
        this.bodyLen = 69;   // 50% bigger
        this.bodyWid = 39;   // 50% bigger
        this.rL = 1.00;
        this.rR = 1.75;
        this.maxWheelSpeed = 180;
        this.accel = 7.0;
        this.vL = 0; this.vR = 0;
        this.tCmd = 0; this.sCmd = 0;
        this.tSlew = 8.0;
        this.sSlew = 12.0;
        this.px = x; this.py = y;
      }

      reset(x, y, heading){
        this.x = x; this.y = y; this.h = heading;
        this.vL = this.vR = 0; this.tCmd = this.sCmd = 0;
        this.px = x; this.py = y;
      }

      update(throttleIn, steerIn, dt){
        const lp = (v, target, slew, dt) => v + (target - v) * (1 - Math.exp(-slew * dt));
        this.tCmd = lp(this.tCmd, constrain(throttleIn, -1, 1), this.tSlew, dt);
        this.sCmd = lp(this.sCmd, constrain(steerIn, -1, 1), this.sSlew, dt);

        const steerMix = 0.85;
        let targetVL = ( this.tCmd - this.sCmd * steerMix) * this.maxWheelSpeed * this.rL;
        let targetVR = ( this.tCmd + this.sCmd * steerMix) * this.maxWheelSpeed * this.rR;

        const lp2 = (v, target) => v + (target - v) * (1 - Math.exp(-this.accel * dt));
        this.vL = lp2(this.vL, targetVL);
        this.vR = lp2(this.vR, targetVR);

        const v = (this.vL + this.vR) * 0.5;
        const omega = (this.vR - this.vL) / this.wheelbase;

        this.h += omega * dt;
        this.x += v * Math.cos(this.h) * dt;
        this.y += v * Math.sin(this.h) * dt;

        let wrappedX = this.x;
        let wrappedY = this.y;
        if (this.x < 0) wrappedX = this.x + width; else if (this.x >= width) wrappedX = this.x - width;
        if (this.y < 0) wrappedY = this.y + height; else if (this.y >= height) wrappedY = this.y - height;

        // Only draw trail if movement didn't wrap (to avoid jump lines)
        if ((wrappedX === this.x && wrappedY === this.y) || (Math.abs(this.x - this.px) < width/2 && Math.abs(this.y - this.py) < height/2)) {
          trailLayer.push();
          trailLayer.stroke('#33FF33');
          trailLayer.strokeWeight(2); // twice as thick
          trailLayer.noFill();
          trailLayer.line(this.px, this.py, this.x, this.y);
          trailLayer.pop();
        }

        this.x = wrappedX;
        this.y = wrappedY;

        this.px = this.x; this.py = this.y;
      }

      draw(){
        push();
        translate(this.x, this.y);
        rotate(this.h);
        stroke(255); noFill(); strokeWeight(2); // twice as thick
        rectMode(CENTER);
        rect(0, 0, this.bodyLen, this.bodyWid, 6);
        const wY = this.bodyWid*0.5 + 3;
        line(-this.bodyLen*0.32, -wY,  this.bodyLen*0.32, -wY);
        ellipse(-this.bodyLen*0.28, -wY, 12*this.rL, 12*this.rL); // 50% bigger
        ellipse( this.bodyLen*0.28, -wY, 12*this.rL, 12*this.rL);
        line(-this.bodyLen*0.32,  wY,  this.bodyLen*0.32,  wY);
        ellipse(-this.bodyLen*0.28,  wY, 12*this.rR, 12*this.rR);
        ellipse( this.bodyLen*0.28,  wY, 12*this.rR, 12*this.rR);
        line(this.bodyLen*0.25, 0, this.bodyLen*0.5, 0);
        pop();
      }
    }
  </script>
</body>
</html>
